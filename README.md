# Лермонтовизация. API

Лермонтовизация по [Пригову](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%B3%D0%BE%D0%B2,_%D0%94%D0%BC%D0%B8%D1%82%D1%80%D0%B8%D0%B9_%D0%90%D0%BB%D0%B5%D0%BA%D1%81%D0%B0%D0%BD%D0%B4%D1%80%D0%BE%D0%B2%D0%B8%D1%87) - это такое преобразование текста при котором все прилагательные в нём заменяются на "безумный" и "неземной".
Поэт Дмитрий Александрович Пригов лермонтовизировал, используя этот метод, [несколько поэтических текстов других авторов](https://arzamas.academy/materials/118).

Настоящий же сервис позволяет преобразовать подобным образом любой русскоязычный текст без учёта стихотворного ритма и размера.
Для меня как автора проекта интерес представляет работа с естественным языком: разбор предложений по составу, поиск в них
прилагательных, определение их формы, постановка эпитетов лермонтовизации в ту же форму.

Мне интересно организовать
backend этого проекта в **микросервисной архитектуре**, а взаимодействие между микросервисами лермонтовизации текстов и микросервисом пользователей - **событийной архитектуре**. Я хочу, чтобы этот проект имел образовательную ценность и продвигал лучшие практики разрабоки. Разумеется, рассчитываю в ходе выполнения проекта устранить собственные недопонимания или заблуждения, касающиеся разработки backend приложений, если они есть.

В предыдущей версии приложения для разбора предложений по составу использовалась библиотека [udpipe](https://github.com/ufal/udpipe), в текущей версии для этого используется библиотека [natasha](https://github.com/natasha/natasha). Для постановки эпитетов лермонтовизации в нужную форму используется библиотека [pymorphy2](https://github.com/pymorphy2/pymorphy2).

## В текущей версии
Сервис предоставляет публичный демонстрационный эндпойнт преобразования текста, не требующий авторизации.
Все преобразования сейчас происходят от имени гостя, то есть в таблицу преобразований текстов сохраняются записи с пустым
(NULL) значением колонки `user_id`.

## Web GUI 
Мой коллега написал frontend-часть для нашего сервиса:
https://github.com/allyotov/lermontovization-frontend

Фронтенд лермонтовизации можно запустить в отдельном Docker-контейнере. Об этом ниже.

## Развёртывание проекта
И мы предусматриваем возможность развёртывания проекта с помощью оркестратора docker compose:
https://github.com/allyotov/lermontovization-web-deploy
Пока там используется предыдущая версия образа без базы данных, поэтому контейнер `Postgres` там тоже не используется.
## Локальный запуск веб-приложения
#### Требования и установка виртуального окружения и зависимостей
Для локального запуска вам потребуется `Python 3.12.7` и пакетный менеджер `uv`, для запуска таргета Makefile'а под в Windows может понадобиться установить утилиту make, в Linux она как правило предустановлена.
Для запуска базы данных Postgres понадобится `Docker` и `docker compose`.

Находясь в директории проекта, выполните следующий (или аналогичный для windows) код в терминале, чтобы активировать виртуальное окружение:
```bash
source ./.venv/bin/activate
```
для синхронизации зависимостей окружения может понадобиться выполнить:
```bash
uv sync
```
#### Задание настроек базы данных и её запуск
Создайте и заполните файлы настроек локальной базы данных и базы данных для тестов: `.env.local` и `.env.test`. Шаблоны заполнения находятся в файлах `.env.local.default` и `.env.test.default`. (Обратите внимание, что в последнем в переменной DB_URL должен быть `разрешённый` путь к б.д., в том смысле, что в правой части соответствующего присваивания не должно быть переменных, так как они не будут разрешаться при выполнении таргетов Makefile'а связанных с тестами).

необходимо запустить контейнер с базой данных:
```bash
make run.db
```
и при первом запуске применить к ней миграции:
```bash
make migrate
```
после чего можно запустить само приложение:
```bash
make run
```
или, если make не доступeн - просто:
```bash
python -m src.main
```
API настоящего сервиса запустится локально на `8000` порту. Можно будет сделать запрос к его эндпойнту:
```bash
  curl -X POST \
  http://0.0.0.0:8000/lermontovization-api/v1/text/lermontovizate \
  -H "Content-Type: application/json" \
  -d '{"text": "Красивый и разумный текст"}'
```
API должен будет вернуть JSON следующего вида:
```json
{"text":"Безумный и неземной текст"}
```
Остановить локальную базу данных можно следующей командой:
```bash
make db.down
```
## Создание миграций базы данных
Для создания нового файла миграции выполните в корне проекта команду следующего вида (виртуальное окружение проекта
должно быть активировано, после флага `-m` укажите название миграции):
```bash
yoyo new -m "add a new active column to texts table"
```
Далее в зависимости от настроек вашего терминала может, например, открыться консольный редактор умолчания vim, вам будет предложено заполнить шаблон очередной миграции конкретными SQL запросами. Можно сделать это прямо там, а можно сохранить шаблон без иземенений (`:w! :q!`) и отредактировать создавшийся файл позже.
После того, как вы создадите новую миграцию, указав в ней нужные SQL запросы, нужно будет "накатить" миграции на локальную и тестовую базы данных, запустив их поочердно (соответствующие команды смотрите выше).
## Тесты
Предусмотрены модульные тесты сервиса лермонтовизации и интеграционные тесты репозитория.
Модульные тесты репозитория я планирую написать в ближайшее время.

Для запуска тестов (конкретно для интеграционных тестов репозитория) понадобится запустить тестовую базу данных
и применить к ней миграции (предполагается, что файл `.env.test` уже создан и заполнен (о его заполнении читайте выше)):
```bash
make run.test.db
```
```bash
make migrate.test.db
```
После этого можно запустить тесты (виртуальное окружение проекта должно быть активировано):
```bash
make test
```
Остановить тестовую базу данных можно следующей командой:
```bash
test.db.down
```

# В процессе:
1. Модульные тесты методов репозитория преобразования текстов;
2. Добавить колонку active в таблицу преобразований текстов (так можно будет помечать преобразования как неактивные, то
есть удалённые).

# Дальнейшее развитие проекта
1. Я планирую написать сервис для работы с пользователями и тем самым добавить в проект аторизацию и аутентификацию. Я хочу чтобы микросервис пользователей передовал данные об изменениях пользователей в настоящий микросервис (API лермонтовизации текстов) через очередь сообщений, реализуя тем самым событийную архитектуру. Благодаря тому, что в lermontovization API будет своя таблица пользователей, он сохранит высокую степень автономности и не будет полностью опираться на user API. Кроме этого можно будет реализовать счётчик лермонтовизаций для каждого зарегистрированного пользователя (и, если нужно, передавать данные об этом в user api так же через очередь сообщений).
2. Предусмотреть пользователя администратора, который сможет удалять и редактировать преобразования текстов других
пользователей, в том числе пользователей-гостей;
3. Добавить telegram бот в качестве альтернативного пользовательского интерфейса.
4. Написать API "переднего" back'а, который был бы посредником между front end'ом и API этого проекта. Это нужно для того, чтобы front end'у не приходилось делать запросы в разные API для получение полной информации по тем же пользователям.

## Известные проблемы

+ После перехода с `ufal.udpipe` на `natasha` (а возможно, после соответствующей переработки кода преобразования текста)
в лермонтовизации текстов иногда начали происходить ошибки морфирования эпитетов лермонтовизации. То есть эпитетам иногда придаётся форма, не соответствующая
форме исходного прилагательного, которое было в тексте до замены. **Нужны тесты и отладка методов сервиса преобразования текста.**